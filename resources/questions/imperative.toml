# Item 1
[[questions]]
question = "Which statement best captures the core <br>principle of the imperative paradigm?"
answer = "Programs specify a sequence of operations <br>that change the programâ€™s state."
alternatives = [
"Programs describe relationships <br>between inputs and outputs.",
"Programs express computation as evaluation <br>of mathematical functions.",
"Programs are composed of rules <br>and logical inferences."
]

# Item 2
[[questions]]
question = "In imperative programming, what does state mutability imply?"
answer = "Variables can change values during <br>execution, altering program state."
alternatives = [
"Variables can only be assigned once.",
"Functions must return new states <br>instead of modifying existing ones.",
"The program cannot have side effects."
]

# Item 3
[[questions]]
question = "Which of the following correctly differentiates <br>procedural programming from object-oriented <br>programming under the imperative paradigm?"
answer = "Procedural organizes code into functions; OOP <br>organizes code into classes and objects."
alternatives = [
"Procedural focuses on state, while <br>OOP focuses on behavior.",
"Procedural uses classes, <br>while OOP avoids them.",
"There is no difference; <br>both are declarative."
]

# Item 4
[[questions]]
question = "What is a major drawback of the imperative <br>approach compared to the declarative one?"
answer = "It requires explicitly managing <br>control flow and state changes."
alternatives = [
"It is less efficient in execution.",
"It cannot handle user-defined data types.",
"It cannot perform recursion."
]

# Item 5
[[questions]]
question = "Which property is shown when the same operation in different <br>parts of an imperative program produces different results?"
answer = "Side effects"
alternatives = [
"Determinism",
"Immutability",
"Referential transparency"
]

# Item 6
[[questions]]
question = "What is a central idea behind logic programming <br>as introduced in Lecture 8A?"
answer = "Computation is performed by stating <br>facts and rules, and letting the <br>system infer answers."
alternatives = [
"Programs explicitly list the <br>step-by-step control flow.",
"All programs are purely functional, <br>with no side effects.",
"Data and functions are merged <br>into objects with methods."
]

# Item 7
[[questions]]
question = "In the context of logic programming, which of the <br>following is not typically a component <br>of a logic program?"
answer = "Explicit loops"
alternatives = [
"Facts",
"Rules",
"Queries"
]

# Item 8
[[questions]]
question = "The query system in logic programming works by:"
answer = "Matching queries against facts and <br>attempting to satisfy conditions <br>via backtracking."
alternatives = [
"Executing statements in a <br>fixed sequence.",
"Translating logic programs to <br>imperative machine code only.",
"Disallowing recursion to avoid <br>infinite loops."
]

# Item 9
[[questions]]
question = "Which statement best captures the difference between <br>logic programming and imperative programming?"
answer = "Logic programming separates what from <br>how, while imperative programming <br>tends to combine both."
alternatives = [
"Imperative programming uses facts <br>and rules; logic programming <br>uses assignments and loops.",
"Logic programming cannot express nondeterminism, <br>while imperative can.",
"In logic programming, state <br>mutation is the norm."
]

# Item 10
[[questions]]
question = "According to the lecture, logic programming <br>systems often incorporate backtracking. <br>Backtracking means:"
answer = "Reversing decisions when they lead to failure <br>and trying alternative paths."
alternatives = [
"Progressing forward in a fixed linear order.",
"Caching previous results to speed up queries.",
"Disallowing recursion."
]